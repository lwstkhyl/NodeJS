<a id="mulu">目录</a>
<a href="#mulu" class="back">回到目录</a>
<style>
    .back{width:40px;height:40px;display:inline-block;line-height:20px;font-size:20px;background-color:lightyellow;position: fixed;bottom:50px;right:50px;z-index:999;border:2px solid pink;opacity:0.3;transition:all 0.3s;color:green;}
    .back:hover{color:red;opacity:1}
    img{vertical-align:bottom;}
</style>

<!-- @import "[TOC]" {cmd="toc" depthFrom=3 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [NodeJS简介](#nodejs简介)
    - [基本使用](#基本使用)
    - [buffer](#buffer)
      - [创建](#创建)
      - [操作](#操作)
      - [补充说明](#补充说明)
    - [进程与线程](#进程与线程)

<!-- /code_chunk_output -->

<!-- 打开侧边预览：f1->Markdown Preview Enhanced: open...
只有打开侧边预览时保存才自动更新目录 -->

写在前面：此笔记来自b站课程[尚硅谷Node.js零基础视频教程](https://www.bilibili.com/video/BV1gM411W7ex) / [资料下载](https://pan.baidu.com/share/init?surl=sDOMvUdY9UF3mlJ7ujOADg&pwd=s3wj#list/path=%2F) 提取码：s3wj
### NodeJS简介
##### 基本使用
Node.js是一种JS运行环境，可以理解成是一个可以运行JS程序的软件
主要用于：构建服务器、开发工具类应用、桌面端应用
此课程使用的nodejs版本为18.12.1，[下载教程](https://blog.csdn.net/jiangjunyuan168/article/details/134216065)，建议先[更改下载地址为镜像网站](https://blog.csdn.net/qq_65142821/article/details/1387331817)

---

**简单使用**：
在vscode中按`ctrl`+``` ` ```键打开终端/右键文件后点击`在集成终端中打开`，输入`node JS文件名`即可使用node.js运行JS文件
![NodeJS简介1](./md-image/NodeJS简介1.png){:width=200 height=200}
之后无特殊说明，代码都是在该文件种编写，并用这种方法运行

---

注意事项：**在Node.js中不能使用DOM和BOM的API**，如`window`、`document`、`navigator`等等
- 浏览器中的JS
    ![NodeJS简介2](./md-image/NodeJS简介2.png){:width=200 height=200}
- Node.js中的JS
    ![NodeJS简介3](./md-image/NodeJS简介3.png){:width=200 height=200}

可以看到`console`和定时器是可以在Node.js中使用的

---

**Node.js中的顶级对象**：不是`window`，而是`global`和`globalThis`（它们指的是同一个对象）
##### buffer
**缓冲区**(buffer)：是一个类似于数组的对象，用于表示固定长度的字节序列
简单来说，buffer就是一段固定长度的内存空间，用于处理二进制数据
**特点**：
- 大小固定且无法更改
- 可以直接操作内存，因此性能较好
- 每个元素的大小为1字节(byte)，是一个8位二进制数

###### 创建
总共有3种方法
- `Buffer.alloc(大小)`
    ```js
    let buf = Buffer.alloc(10); //长度为10字节
    console.log(buf); 
    //<Buffer 00 00 00 00 00 00 00 00 00 00>
    ```
- `Buffer.allocUnsafe(大小)`
    ```js
    let buf = Buffer.allocUnsafe(10000);
    console.log(buf);
    //<Buffer f0 2c 05 c8 4e 02 00 00 ... 9950 more bytes>
    ```
    与上面`alloc`的区别：`allocUnsafe`使用的内存可能包含旧的内存数据。`alloc`会先对使用的内存进行清空归零，而`allocUnsafe`不会，因此结果中会有非零值，这就是旧的内存数据
    优点：速度比`alloc`更快
- `Buffer.from(字符串/数组)`将字符串或数组转换为buffer
    转换规则：每个字符/数组中元素都转为Unicode中的编码，该编码再转成二进制形式，存入buffer数组中
    ```js
    let buf = Buffer.from('hello');
    console.log(buf);
    //<Buffer 68 65 6c 6c 6f>
    let buf2 = Buffer.from([10, 101, 200, 119]);
    console.log(buf2);
    //<Buffer 0a 65 c8 77>
    ```
    为什么输出的是16进制：终端输出运行结果时，会对二进制数字进行转换，方便查看
###### 操作
- buffer与字符串的转换：`buf.toString()`
    ```js
    let buf = Buffer.from([105, 108, 111, 118, 101, 121, 111, 117]);
    console.log(buf.toString());
    //iloveyou
    ```
    注意：默认是utf-8编码
- 读写：可以直接使用`buf[index]`的方式获取/修改元素
    ```js
    let buf = Buffer.from([105, 108, 111, 118, 101, 121, 111, 117]);
    console.log(buf[0]); //105
    console.log(buf[0].toString(2)); //1101001
    buf[0] = 95; //修改
    console.log(buf); //<Buffer 5f 6c 6f 76 65 79 6f 75>
    console.log(buf.toString()); //_loveyou
    ```
    其中`buf[0].toString(2)`是将该元素转为2进制，终端输出时会自动省略前面的0，因此结果只有7位，实际结果应为`01101001`
###### 补充说明
- **溢出**：因为buffer的每个元素是8位2进制，最大只能保存255。如果将元素修改为>255的数，则会将高位数字舍弃
    ```js
    let buf = Buffer.from('hello');
    buf[0] = 361; //二进制为0001 0110 1001
    console.log(buf[0]); //105 只保留0110 1001
    console.log(buf); //<Buffer 69 65 6c 6c 6f>
    ```
- **中文**：也使用utf-8编码，一个汉字占3字节
    ```js
    let buf = Buffer.from('你好');
    console.log(buf); //<Buffer e4 bd a0 e5 a5 bd>
    ```
##### 进程与线程
进程：程序的一次执行过程，可以理解为正在执行的程序
线程：一个进程中执行的一个执行流，一个线程是属于某个进程的，一个进程至少包含一个线程
查看某个进程中的线程：下载pslist.exe，cmd中输入`pslist -dmx 进程PID`，进程PID在任务管理器的详细信息中
