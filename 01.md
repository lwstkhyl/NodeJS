<a id="mulu">目录</a>
<a href="#mulu" class="back">回到目录</a>
<style>
    .back{width:40px;height:40px;display:inline-block;line-height:20px;font-size:20px;background-color:lightyellow;position: fixed;bottom:50px;right:50px;z-index:999;border:2px solid pink;opacity:0.3;transition:all 0.3s;color:green;}
    .back:hover{color:red;opacity:1}
    img{vertical-align:bottom;}
</style>

<!-- @import "[TOC]" {cmd="toc" depthFrom=3 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [NodeJS简介](#nodejs简介)
    - [基本使用](#基本使用)
    - [buffer](#buffer)
      - [创建](#创建)
      - [操作](#操作)
      - [补充说明](#补充说明)
    - [进程与线程](#进程与线程)
- [fs模块](#fs模块)
    - [文件写入](#文件写入)
    - [文件读取](#文件读取)

<!-- /code_chunk_output -->

<!-- 打开侧边预览：f1->Markdown Preview Enhanced: open...
只有打开侧边预览时保存才自动更新目录 -->

写在前面：此笔记来自b站课程[尚硅谷Node.js零基础视频教程](https://www.bilibili.com/video/BV1gM411W7ex) / [资料下载](https://pan.baidu.com/share/init?surl=sDOMvUdY9UF3mlJ7ujOADg&pwd=s3wj#list/path=%2F) 提取码：s3wj
### NodeJS简介
##### 基本使用
Node.js是一种JS运行环境，可以理解成是一个可以运行JS程序的软件
主要用于：构建服务器、开发工具类应用、桌面端应用
此课程使用的nodejs版本为18.12.1，[下载教程](https://blog.csdn.net/jiangjunyuan168/article/details/134216065)，建议先[更改下载地址为镜像网站](https://blog.csdn.net/qq_65142821/article/details/1387331817)

---

**简单使用**：
在vscode中按`ctrl`+``` ` ```键打开终端/右键文件后点击`在集成终端中打开`，输入`node JS文件名`即可使用node.js运行JS文件
![NodeJS简介1](./md-image/NodeJS简介1.png){:width=200 height=200}
之后无特殊说明，代码都是在该文件种编写，并用这种方法运行

---

注意事项：**在Node.js中不能使用DOM和BOM的API**，如`window`、`document`、`navigator`等等
- 浏览器中的JS
    ![NodeJS简介2](./md-image/NodeJS简介2.png){:width=200 height=200}
- Node.js中的JS
    ![NodeJS简介3](./md-image/NodeJS简介3.png){:width=200 height=200}

可以看到`console`和定时器是可以在Node.js中使用的

---

**Node.js中的顶级对象**：不是`window`，而是`global`和`globalThis`（它们指的是同一个对象）
##### buffer
**缓冲区**(buffer)：是一个类似于数组的对象，用于表示固定长度的字节序列
简单来说，buffer就是一段固定长度的内存空间，用于处理二进制数据
**特点**：
- 大小固定且无法更改
- 可以直接操作内存，因此性能较好
- 每个元素的大小为1字节(byte)，是一个8位二进制数

###### 创建
总共有3种方法
- `Buffer.alloc(大小)`
    ```js
    let buf = Buffer.alloc(10); //长度为10字节
    console.log(buf); 
    //<Buffer 00 00 00 00 00 00 00 00 00 00>
    ```
- `Buffer.allocUnsafe(大小)`
    ```js
    let buf = Buffer.allocUnsafe(10000);
    console.log(buf);
    //<Buffer f0 2c 05 c8 4e 02 00 00 ... 9950 more bytes>
    ```
    与上面`alloc`的区别：`allocUnsafe`使用的内存可能包含旧的内存数据。`alloc`会先对使用的内存进行清空归零，而`allocUnsafe`不会，因此结果中会有非零值，这就是旧的内存数据
    优点：速度比`alloc`更快
- `Buffer.from(字符串/数组)`将字符串或数组转换为buffer
    转换规则：每个字符/数组中元素都转为Unicode中的编码，该编码再转成二进制形式，存入buffer数组中
    ```js
    let buf = Buffer.from('hello');
    console.log(buf);
    //<Buffer 68 65 6c 6c 6f>
    let buf2 = Buffer.from([10, 101, 200, 119]);
    console.log(buf2);
    //<Buffer 0a 65 c8 77>
    ```
    为什么输出的是16进制：终端输出运行结果时，会对二进制数字进行转换，方便查看
###### 操作
- buffer与字符串的转换：`buf.toString()`
    ```js
    let buf = Buffer.from([105, 108, 111, 118, 101, 121, 111, 117]);
    console.log(buf.toString());
    //iloveyou
    ```
    注意：默认是utf-8编码
- 读写：可以直接使用`buf[index]`的方式获取/修改元素
    ```js
    let buf = Buffer.from([105, 108, 111, 118, 101, 121, 111, 117]);
    console.log(buf[0]); //105
    console.log(buf[0].toString(2)); //1101001
    buf[0] = 95; //修改
    console.log(buf); //<Buffer 5f 6c 6f 76 65 79 6f 75>
    console.log(buf.toString()); //_loveyou
    ```
    其中`buf[0].toString(2)`是将该元素转为2进制，终端输出时会自动省略前面的0，因此结果只有7位，实际结果应为`01101001`
###### 补充说明
- **溢出**：因为buffer的每个元素是8位2进制，最大只能保存255。如果将元素修改为>255的数，则会将高位数字舍弃
    ```js
    let buf = Buffer.from('hello');
    buf[0] = 361; //二进制为0001 0110 1001
    console.log(buf[0]); //105 只保留0110 1001
    console.log(buf); //<Buffer 69 65 6c 6c 6f>
    ```
- **中文**：也使用utf-8编码，一个汉字占3字节
    ```js
    let buf = Buffer.from('你好');
    console.log(buf); //<Buffer e4 bd a0 e5 a5 bd>
    ```
##### 进程与线程
**进程**：程序的一次执行过程，可以理解为正在执行的程序
**线程**：一个进程中执行的一个执行流，一个线程是属于某个进程的，一个进程至少包含一个线程
查看某个进程中的线程：下载pslist.exe，cmd中输入`pslist -dmx 进程PID`，进程PID在任务管理器的详细信息中
### fs模块
即file system，可以实现与内存/硬盘的交互，如文件/文件夹的创建删除、文件内容的读写等
**在使用任何模块前都需要进行导入**：
```js
const 变量名 = require('模块名');
//例如：
const fs = require('fs');
```
其中`const`也可以是`var`/`let`，`require`是导入模块的函数，变量名可以任取（一般与模块名相同），之后调用模块中的函数都用这个变量名
##### 文件写入
- **覆盖写入（同步/异步）**`fs.writeFile(file, data[, options], callback)`/`fs.writeFileSync(file, data[, options])`
- **追加写入（同步/异步）**`fs.appendFile(file, data[, options], callback)`/`fs.appendFileSync(file, data[, options])`
  - `file`文件名，如果不存在则自动创建
  - `data`要写入的数据
  - `callback`回调函数。接收1个参数`err`（变量名可任取），当写入失败时，`err`为错误对象；成功时`err`为null
  - `options`其它选项
  - 无返回值
- **流式写入**：
    ```js
    const ws = fs.createWriteStream(file);
    ws.write(data);
    ws.close();
    ```

例：
```js
const fs = require('fs');
fs.writeFile('./test.txt', 'hello node.js', err => {
    if (err) {
        console.log('写入失败');
        return;
    }
    console.log('写入成功');
});
```
该段程序将`'hello node.js'`覆盖写入`test.txt`中
![文件写入1](./md-image/文件写入1.png){:width=150 height=150}

---

**异步写入**：有两个线程。**JS主线程**自上而下运行代码，遇到`writeFile`函数时，将写入操作交给**I/O线程**，此时JS主线程继续向下执行，不会等待I/O线程完成写入操作；当I/O线程完成写入操作后，它将回调函数放入JS主线程的任务队列中，根据JS主线程的事件循环机制来执行回调函数（即等待js文件中的其它代码执行后，再执行回调函数）
一个例子：
```js
const fs = require('fs');
fs.writeFile('./test.txt', 'hello node.js', err => {
    if (err) {
        console.log('写入失败');
        return;
    }
    console.log('写入成功');
});
console.log('123');
```
会先输出`123`再输出`写入成功`
**同步写入**：当JS主线程执行到该函数时，会等待I/O线程执行完毕后再往下执行。同步比异步的性能差

---

**追加写入**：不仅可以用`appendFile`系列函数，还可以用`writeFile`系列函数
方法：设置`option`参数的`flag`为`'a'`（追加写入append），该属性默认为`'w'`（覆盖写入write）
```js
const fs = require('fs');
fs.writeFile('./test.txt', '原有内容', err => {
    if (err) {
        console.log('写入失败');
        return;
    }
    console.log('写入成功');
});
fs.writeFile('./test.txt', '\n追加内容1', { flag: 'a' }, err => {
    if (err) {
        console.log('写入失败');
        return;
    }
    console.log('写入成功');
});
fs.appendFile('./test.txt', '\n追加内容2', err => {
    if (err) {
        console.log('写入失败');
        return;
    }
    console.log('写入成功');
});
```
![文件写入2](./md-image/文件写入2.png){:width=200 height=200}

---

**流式写入**：先创建写入流对象（可以理解成一个通道/链接），再使用write函数追加写入，最后关闭通道。与python里面的文件写入类似
```js
const fs = require('fs');
const ws = fs.createWriteStream('./test.txt'); //创建写入流对象
ws.write('追加内容1\n');
ws.write('追加内容2\n');
ws.write('追加内容3\n'); //追加写入
ws.close(); //关闭通道（可省略）
```
![文件写入3](./md-image/文件写入3.png){:width=100 height=100}
流式写入可以减少打开/关闭文件的次数，适用于大文件写入/频繁写入，而前面的方法适用于频率较低的写入

---

**文件写入的应用场景**：下载文件、安装软件、保存程序日志（比如git）、文本编辑器保存、视频录制等等
注意：当需要**持久化保存数据**时，应使用文件写入
##### 文件读取
- **异步读取**`fs.readFile(file[, option], callback)`，无返回值
  - `file`文件名，如果不存在则自动创建
  - `callback`回调函数，接收2个参数，分别为`err`和`data`
    - `err`与[文件写入](#文件写入)中的相同
    - `data`为文件内容，是buffer的形式
  - `options`其它选项
- **同步读取**`fs.readFileSync(file[, option])`，直接返回读取的数据，也是buffer的形式
- **流式读取**：可以理解成将文件分成多块读取，每一块的最大大小为65536字节(64KB)，适用于大文件的读取
    ```js
    const rs = fs.createReadStream(file); //创建读取流对象
    rs.on('data', chunk => { }); //绑定data事件
    rs.on('end', () => { }); //绑定end事件
    ```
    - data事件：每读取一块文件时触发，读取到的数据存入`chunk`中
    - end事件（可选）：当整个文件读取完成后触发

例：
```js
//异步读取
const fs = require('fs');
fs.readFile('./test.txt', (err, data) => {
    if (err) {
        console.log("读取失败");
        return;
    }
    console.log(data);
    console.log(data.toString());
});
```
![文件读取1](./md-image/文件读取1.png){:width=100 height=100}
```js
//同步读取
const fs = require('fs');
let data = fs.readFileSync('./test.txt');
console.log(data.toString());
```
![文件读取2](./md-image/文件读取2.png){:width=50 height=50}
```js
//流式读取
const fs = require('fs');
const rs = fs.createReadStream("./data/test.jpg");
rs.on('data', chunk => {
    console.log(chunk);
    console.log(chunk.length);
});
rs.on('end', () => {
    console.log("读取完毕");
});
```
![文件读取3](./md-image/文件读取3.png){:width=250 height=250}
注：使用的文件大小为146KB

---

**文件读取的应用场景**：程序运行、打开/查看文件、上传文件、git查看日志等等

---

**例：文件复制**，即先读取文件，再写入
```js
const fs = require('fs');
//方式1：同步读写
const data = fs.readFileSync('./test.txt'); //读取文件内容
fs.writeFileSync('./test_copy.txt', data); //写入文件
//方式2：异步读写
fs.readFile('./test.txt', (err, data) => {
    if (err) {
        console.log("读取失败");
        return;
    }
    fs.writeFile('./test_copy.txt', data, err => {
        if (err) {
            console.log('写入失败');
            return;
        }
    });
});
//方式3：流式读写
const rs = fs.createReadStream('./test.txt'); //读取流对象
const ws = fs.createWriteStream('./test_copy.txt'); //写入流对象
rs.on('data', chunk => {
    ws.write(chunk); //每读取一块就写入一块
});
//方式4：流式读写，使用pipe函数，效果更好
rs.pipe(ws); //pipe：将rs的数据输入ws中
```
对于同步/异步读取，是先把文件的所有内容获取，存入内存中，再进行写入，因此读取大文件需要消耗大量的内存空间；而对于流式读写，每次只读取64KB的内容并写入，因此理想状态下只需要64KB的内存空间就可以完成（实际情况下由于读取速度更快，会有一些内容堆积在内存中等待写入，但仍比同步/异步读取占用内存小）
使用`process`模块来查看内存占用：
- 同步读写
    ```js
    const fs = require('fs');
    const process = require('process');
    const data = fs.readFileSync('./test.png');
    fs.writeFileSync('./test_copy1.png', data);
    console.log(process.memoryUsage());
    //rss: 29728768
    ```
- 异步读写
    ```js
    const fs = require('fs');
    const process = require('process');
    fs.readFile('./test.png', (err, data) => {
        if (err) {
            console.log("读取失败");
            return;
        }
        fs.writeFile('./test_copy2.png', data, err => {
            if (err) {
                console.log('写入失败');
                return;
            }
            console.log(process.memoryUsage());
        });
    });
    //rss: 29859840
    ```
- 流式读写
    ```js
    const fs = require('fs');
    const process = require('process');
    const rs = fs.createReadStream('./test.png');
    const ws = fs.createWriteStream('./test_copy3.png');
    rs.pipe(ws);
    console.log(process.memoryUsage());
    //rss: 28454912
    ```

由于这里使用的文件大小仅为1MB左右，内存节省不明显。如果想要看到明显效果，至少要10MB数量级
