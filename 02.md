<a id="mulu">目录</a>
<a href="#mulu" class="back">回到目录</a>
<style>
    .back{width:40px;height:40px;display:inline-block;line-height:20px;font-size:20px;background-color:lightyellow;position: fixed;bottom:50px;right:50px;z-index:999;border:2px solid pink;opacity:0.3;transition:all 0.3s;color:green;}
    .back:hover{color:red;opacity:1}
    img{vertical-align:bottom;}
</style>

<!-- @import "[TOC]" {cmd="toc" depthFrom=3 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [模块化](#模块化)
    - [暴露数据](#暴露数据)
    - [导入模块](#导入模块)

<!-- /code_chunk_output -->

<!-- 打开侧边预览：f1->Markdown Preview Enhanced: open...
只有打开侧边预览时保存才自动更新目录 -->

写在前面：此笔记来自b站课程[尚硅谷Node.js零基础视频教程](https://www.bilibili.com/video/BV1gM411W7ex) P67-P / [资料下载](https://pan.baidu.com/share/init?surl=sDOMvUdY9UF3mlJ7ujOADg&pwd=s3wj#list/path=%2F) 提取码：s3wj

### 模块化
模块化：将一个复杂的程序文件依据一定规则拆分成多个文件。其中拆分出的每个文件就是一个模块，模块内部数据是私有的，也可以提供接口（暴露数据）让其它模块使用
好处：减少变量命名冲突、高复用性、高维护性
##### 暴露数据
为方便说明，这里定义`值名`为某个模块中的值名称，`调用值名`为在其它文件中调用该模块中值时使用的值名称
- `module.exports`：
  - `module.exports = 值名`将指定值暴露除去，此时调用值名与值名相同。在需要调用该值的js文件中，使用`const 调用值名=require('模块名')`即可获得该值
    注：这种方法只能暴露1个值
  - `module.exports = {调用值名1:值名1, 调用值名2:值名2, ...}`将多个值暴露出去，调用值名可不写，默认与值名相同。此时调用该模块的方法同前面讲过的模块调用

  例：创建`my_func.js`文件作为模块文件
    ```js
    //my_func.js
    function func_a() {
        console.log("我是a函数");
    }
    module.exports = func_a;
    //其它js文件调用该函数
    const func_a = require('./my_func.js');
    func_a(); //我是a函数
    ```
    ```js
    //my_func.js
    function func_a() {
        console.log("我是a函数");
    }
    function func_b() {
        console.log("我是b函数");
    }
    module.exports = {
        func_a,
        my_func_b: func_b
    };
    //其它js文件调用该函数
    const my_func = require('./my_func.js');
    my_func.func_a(); //我是a函数
    my_func.my_func_b(); //我是b函数
    ```
- `exports.调用值名 = 值名`这种方法可以暴露多个函数
    ```js
    //my_func.js
    function func_a() {
        console.log("我是a函数");
    }
    function func_b() {
        console.log("我是b函数");
    }
    exports.func_a = func_a;
    exports.my_func_b = func_b;
    //其它js文件调用该函数
    const my_func = require('./my_func.js');
    my_func.func_a(); //我是a函数
    my_func.my_func_b(); //我是b函数
    ```

注意：
- 暴露的数据可以是任意类型的
    ```js
    //my_func.js
    str = '我是字符串';
    num = 100;
    exports.str = str;
    exports.num = num;
    //其它js文件调用该函数
    const my_func = require('./my_func.js');
    console.log(my_func.str, my_func.num); //我是字符串 100
    ```
- 不能使用`exports = 值名`的形式，因为`exports`实际上是指向`module.exports`的指针，而`module.exports`是一个空对象，如果这样写就是将该指针覆盖了，而`exports.调用值名 = 值名`则是向`module.exports`中添加数据
##### 导入模块
**使用require导入模块的注意事项**：
- 如果是nodejs内置模块，直接写模块名即可；而对于自己创建的模块，导入时建议写相对路径，且不能省略`./`和`../`
    注：这里的相对路径不受工作目录的影响，都是以文件目录为准
- js和json文件引入时可以省略后缀（如果同名，优先引入js），json文件引入时会自动转为对象形式。c/c++编写的`.node`扩展文件也可省略后缀（不常用）
- 导入未知类型的文件或没有后缀的文件，会默认按js文件处理

**导入文件夹**：当导入的路径是一个文件夹时，
- 会首先检测文件夹中`package.json`中`main`属性对应的文件，如果存在则导入这些文件，如果不存在其中某个文件则报错
- 如果没有`package.json`或`package.json`中没有`main`属性，则会尝试导入文件夹中`index.js`和`index.json`，如果不存在这两个文件则报错

```js
//module文件夹下app.js
module.exports = "我是一个模块";
//module文件夹下package.json
{
    "main": "./app.js"
}
//其它js文件调用该文件夹
const m = require('./module');
console.log(m); //我是一个模块
```
```js
//module文件夹下index.js
module.exports = "我是一个index.js";
//其它js文件调用该文件夹
const m = require('./module');
console.log(m); //我是一个index.js
```

---

**require导入自定义模块的基本流程**：
- 将相对路径转为绝对路径，定位文件
- 缓存检测：检测之前有没有导入过这个文件，如果导入过，就直接利用缓存值，不用重复执行这个文件了
- 读取代码
- 将代码封装成一个函数并执行（自执行函数）
- 缓存模块的值
- 返回`module.exports`的值

```js
//module文件夹下index.js
module.exports = "我是一个index.js";
console.log(arguments.callee.toString()); //输出自执行函数内容
//其它js文件调用该文件夹
const m = require('./module');
const m1 = require('./module');
```
```
function (exports, require, module, __filename, __dirname) {
module.exports = "我是一个index.js";
console.log(arguments.callee.toString()); //输出自执行函数内容

}
```
导入了两次模块，只输出了一次自执行函数，这是因为第二次导入模块时使用了第一次导入的缓存

---

补充：`module.exports`、`exports`、`require`这些都是CommonJS模块化规范中的内容，而Node.js是CommonJS模块化规范的具体实现。Nodejs与CommonJS的关系类似于JavaScript与ECMAScript
