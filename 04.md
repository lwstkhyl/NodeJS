<a id="mulu">目录</a>
<a href="#mulu" class="back">回到目录</a>
<style>
    .back{width:40px;height:40px;display:inline-block;line-height:20px;font-size:20px;background-color:lightyellow;position: fixed;bottom:50px;right:50px;z-index:999;border:2px solid pink;opacity:0.3;transition:all 0.3s;color:green;}
    .back:hover{color:red;opacity:1}
    img{vertical-align:bottom;}
</style>

<!-- @import "[TOC]" {cmd="toc" depthFrom=3 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [会话控制](#会话控制)
    - [cookie](#cookie)
      - [浏览器操作cookie](#浏览器操作cookie)
      - [express框架中的cookie](#express框架中的cookie)

<!-- /code_chunk_output -->

<!-- 打开侧边预览：f1->Markdown Preview Enhanced: open...
只有打开侧边预览时保存才自动更新目录 -->

写在前面：此笔记来自b站课程[尚硅谷Node.js零基础视频教程](https://www.bilibili.com/video/BV1gM411W7ex) P168-P200 / [资料下载](https://pan.baidu.com/share/init?surl=sDOMvUdY9UF3mlJ7ujOADg&pwd=s3wj#list/path=%2F) 提取码：s3wj

### 会话控制
**会话**：客户端向服务端发送一次请求，服务端响应一次信息，就是一次会话
HTTP是一种无状态的协议，无法区分多次请求是否来自同一个客户端，即无法区分用户。这时就需要会话控制解决该问题，常见的会话控制有三种：
\- [cookie](#cookie)
\- session
\- token
##### cookie
cookie是HTTP服务器发送到用户浏览器并保存在本地的一小块数据，是按照域名划分的，形式类似于键值对
**特点**：浏览器向服务器发送请求时，会自动将**当前域名下**可用的cookie设置在请求头中，传递给服务器
这个请求头的名称也叫`cookie`，因此也可将cookie理解成一个HTTP请求头
**运行流程**：以登录操作为例
- 在浏览器输入账号密码后，该信息被发送给服务器，服务器校验正确后，将属于该客户的cookie返回（响应头`set-cookie`）
    ![cookie1](./md-image/cookie1.png){:width=300 height=300}
- 有了cookie之后，再向服务器发送请求时，就会自动携带cookie
    ![cookie2](./md-image/cookie2.png){:width=250 height=250}
###### 浏览器操作cookie
使用较少，了解即可
- 禁用所有cookie：打开网页设置页面，搜索`cookie`，找到`管理和删除 cookie 和站点数据`->`阻止第三方Cookie`，开启后很多网页无法正常使用
  ![cookie3](./md-image/cookie3.png){:width=150 height=150}
- 删除cookie：还是上面的页面，点击`查看所有 Cookie和站点数据`，就可以查看和删除各网页的cookie
  ![cookie4](./md-image/cookie4.png){:width=200 height=200}
  如果在一个网站上已经登录，此时删除了该网站的cookie，就无法自动登录了
- 查看cookie：
  - edge：还是上面的`查看所有 Cookie和站点数据`，点击右侧箭头展开
    ![cookie5](./md-image/cookie5.png){:width=100 height=100}
    ![cookie6](./md-image/cookie6.png){:width=500 height=500}
    其中名称是键、内容是值
  - chrome：新版chrome无法通过简单的方式查看，以下是旧版的操作
    ![cookie7](./md-image/cookie7.png){:width=150 height=150}
    点击箭头展开
    ![cookie8](./md-image/cookie8.png){:width=300 height=300}
  - 所有浏览器都可使用的方法：f12->控制台->`document.cookie`
    ![cookie11](./md-image/cookie11.png){:width=100 height=100}
注：**不同浏览器的cookie不共享**。在一个浏览器中登录一个网页，在另一个浏览器中打开这个网页时仍需登录
为什么打开一个网页，会有显示有其它网页的cookie：网页中有其它的组件也需要cookie，进入一个网页时，会向其它多个网页发送cookie。此网页的cookie被称为**第一方cookie**，其它发送的cookie被称为**第三方cookie**
###### express框架中的cookie
**设置cookie**：
- `res.cookie(cookie名, cookie值)`这种方式在浏览器关闭时销毁cookie
- `res.cookie(cookie名, cookie值, {maxAge: cookie存在时间})`指定cookie的存在时间，单位是ms

**例1**：
```js
const express = require("express");
const app = express();
app.get('/set-cookie', (req, res) => {
    res.cookie('name', 'abc'); //设置cookie
    res.send("home");
});
app.listen(9000);
```
进入`http://127.0.0.1:9000/set-cookie`后，响应头中可以看到`set-cookie`
![cookie9](./md-image/cookie9.png){:width=300 height=300}
刷新页面，重新发送请求，就可以在请求体中看见刚才设置的cookie
![cookie10](./md-image/cookie10.png){:width=300 height=300}
一个问题：如果访问`http://127.0.0.1:9000`，请求中会不会携带cookie？因为域名没变，所以还是会带这个cookie
**例2**：cookie的生命周期
```js
const express = require("express");
const app = express();
app.get('/set-cookie', (req, res) => {
    res.cookie('name', 'abc', { maxAge: 30*1000 }); //设置cookie生命周期
    res.send("home");
});
app.listen(9000);
```
先进入`http://127.0.0.1:9000/set-cookie`设置cookie，再打开`http://127.0.0.1:9000`，可以在请求头中看到cookie，30s后再次进入，就不会看到cookie了
![cookie12](./md-image/cookie12.png){:width=300 height=300}
可以看到cookie的生命周期、过期时间
注：这里面`Max-Age`的单位是s
